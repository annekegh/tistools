#!/usr/bin/env python
"""
tistools-running-error: Running estimate error analysis for REPPTIS simulations.

Computes running estimates at regular intervals using recursive formulas.
Useful for monitoring convergence and computing error when block error is large.

Outputs:
  - Running estimates of tau, flux, P_cross, rate, MFPT
  - Both MSM-based and standard REPPTIS methods

Usage:
    tistools-running-error <simulation_dir> [options]

Example:
    tistools-running-error /path/to/repptis_sim --interval 10000 --skip 25000
"""

import argparse
import sys
from pathlib import Path

import numpy as np


def parse_args():
    parser = argparse.ArgumentParser(
        description="Running estimate error analysis for REPPTIS simulations.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "simdir",
        type=str,
        help="Path to REPPTIS simulation directory",
    )
    parser.add_argument(
        "--interval", "-i",
        type=int,
        default=10000,
        help="Interval between running estimates in cycles (default: 10000)",
    )
    parser.add_argument(
        "--skip", "-s",
        type=int,
        default=0,
        help="Cycles to skip from beginning (default: 0)",
    )
    parser.add_argument(
        "--load-orders",
        action="store_true",
        help="Load order parameters from .npy files",
    )
    parser.add_argument(
        "--output", "-o",
        type=str,
        default=None,
        help="Output file for results (default: stdout)",
    )
    parser.add_argument(
        "--quiet", "-q",
        action="store_true",
        help="Only print final summary, not running estimates",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    # Import tistools functions
    try:
        from tistools import load_path_ensembles, block_error_analysis
    except ImportError as e:
        print(f"Error: Could not import tistools: {e}", file=sys.stderr)
        sys.exit(1)

    # Setup paths
    simdir = Path(args.simdir).resolve()
    if not simdir.exists():
        print(f"Error: Directory {simdir} does not exist", file=sys.stderr)
        sys.exit(1)

    # Output setup
    out = open(args.output, "w") if args.output else sys.stdout

    def log(msg):
        print(msg, file=out)

    log("=" * 80)
    log("RUNNING ESTIMATE ERROR ANALYSIS")
    log("=" * 80)
    log(f"Simulation: {simdir}")
    log(f"Interval: {args.interval} cycles")
    log(f"Skip from start: {args.skip}")
    log("")

    # Load path ensembles
    log("Loading path ensembles...")
    path_ensembles, interfaces = load_path_ensembles(str(simdir), load=args.load_orders)

    # Apply initial skip
    for pe in path_ensembles:
        pe.prune_start_pe(args.skip)

    max_cycles = min(len(pe.flags) for pe in path_ensembles)
    log(f"Available cycles after skip: {max_cycles}")
    log("")

    if not args.quiet:
        log("RUNNING ESTIMATES")
        log("-" * 80)
        header = (
            f"{'Cycle':>8} "
            f"{'tau_m':>12} {'MSM_tau_p':>12} {'REP_tau_p':>12} "
            f"{'MSM_flux':>12} {'REP_flux':>12} "
            f"{'MSM_Pcross':>12} {'REP_Pcross':>12} "
            f"{'MSM_rate':>12} {'REP_rate':>12}"
        )
        log(header)
        log("-" * len(header))

    # Run block error analysis (which prints running estimates)
    # We capture and parse the output, or run our own loop
    # For simplicity, call the existing function with interval
    block_error_analysis(path_ensembles, interfaces, interval=args.interval, load=False)

    log("")
    log("=" * 80)
    log("Analysis complete. See running estimates above for convergence.")
    log("=" * 80)

    if args.output:
        out.close()
        print(f"Results written to {args.output}")


if __name__ == "__main__":
    main()
