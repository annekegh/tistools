#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar  3 13:41:12 2021

@author: wouter
"""

if __name__ == '__main__':

    from wholemake_scripts import read_chunk_paths, execute_command
    import os
    import numpy as np
    import time 
    import MDAnalysis as mda
    import subprocess
    import sys
    from MDAnalysis.analysis import align
    from MDAnalysis.analysis import distances

    from optparse import OptionParser
    usage = "usage: %prog [options] file1 [file2 ...]"
    parser = OptionParser(usage=usage)

    parser.add_option("-f", dest="chunk_fn", default=None, \
            help="chunk_fn is the filename where the trajectories \
            to be recalculated are saved.")
    parser.add_option("-c", dest="cid", default=None, \
            help="chunk id, integer 0<cid<procs_used")
    parser.add_option("--tpx", action="store", type="string", \
            dest="tpx_version", default="old", help="Did you use \
            the old or new version of TPX to generate the \
            trajectory? So use old or new keyword.")
    parser.add_option("--reqfolder", action="store", type="string", \
            dest="reqfolder", default="required_files_for_recalc", \
            help="The folder having the .tpr, .npy, .txt files for \
            the orderparamter recalculation")
    parser.add_option("--ref_frame", action="store", type="int", \
            dest="ref_frame", default=101, help="The frame of \
            fullsimcenter.xtc that is used to align the frames to.")
    parser.add_option("-o", action="store", type="string",
            dest="outf", default=".",
            help="you know, outf")
    (options, args) = parser.parse_args()
    print("options: ")
    print(options.__dict__)
    print("args: ")
    print(args)
    
    chunk_fn = options.chunk_fn
    cid = options.cid
    outf = options.outf
    # Load the trajectory paths
    traj_files = read_chunk_paths(chunk_fn)

    # Definitions
    def write_order(l,fn,dt=1):
        # l is a list of orderparameters, just write them out to a txt file line by line
        with open(fn, 'w+') as f:
            for i,el in enumerate(l):
                f.write(str(int(i*dt))+"\t")
                f.write(str(el)+"\n")
        f.close()
    
    def get_rigid_residues_id(gro_complex, traj_complex, rmsf_limit, align_frame = 101,reqfolder=""):
        """
        Parameters
        ----------
        gro_complex : .gro 
            GROMACS structure file of protein-ligand complex
        traj_complex : .xtc 
            GROMACS trajectory file of protein-ligand complex
        rmsf_limit : float
            upper limit of residue rmsf [nm].
        align_frame: int
            Frame number to which all other frames are aligned.
            I distrust frame 0 of trajectory files, whose orientation
            is often compeletely different than frame 1,2,3...
        Returns
        -------
        Returns and saves to file: the selection string (mdtraj) of residue-indices
        whose carbon alpha RMSF is lower or equal to rmsf_limit as well as a 
        selection string for the CA atoms of the rigid residues.
    
        """
        
        print("This inner function is surely only used once")
        
        # Load trajectory, and restrict to carbon alpha atoms
        traj = md.load_xtc(traj_complex,gro_complex)
        sel_CA = traj.topology.select('name CA')
        traj.restrict_atoms(sel_CA)
        
        # Align frames to align_frame
        traj.superpose(traj,align_frame)
        
        # Calculate the residue covariance
        natom = traj.xyz.shape[1]
        xyz = traj.xyz.reshape(-1,natom*3)[101:]
        covar = np.cov(xyz,rowvar=False)
        
        # Make a new selection for the carbon alpha atoms, because
        # the restrict_atoms command re-indexes the atoms in the 
        # restricted topology object. Same holds for atom_slice. Note
        # however that residue indices DO NOT change, even if you
        # remove some from the topology! e.g.: remove first five
        # residues, then traj.top.residue(0).index = 6, while 
        # traj.top.atom(0).index = 0. 
        sel_new_CA = traj.top.select('name CA')
        sel_new_CA_xyz = np.array([3*sel_new_CA,3*sel_new_CA+1, 3*sel_new_CA+2]).T.ravel()
        
        # Calculate the residue RMSF
        rmsf = np.sqrt(np.diag(covar)[sel_new_CA_xyz].reshape(-1,3).sum(axis=1))
        
        # Select those residues with RMSF <= rmsf_limit, and save 
        # them to mdtraj selection compatible string.
        rigid_sel_string=""
        for i, fluc in enumerate(rmsf):
            if fluc <= rmsf_limit:
                rigid_sel_string+="(resid "+str(i)+") or "
        rigid_sel_string = rigid_sel_string[:-4]
        
        # Also make a string to select the CA atoms of the rigid
        # residues, rather than all atoms of the rigid residues.
        rigid_CA_sel_string = '('+rigid_sel_string+') and name CA'
        
        with open(reqfolder+"rigid_residues.txt",'w+') as f:
            f.write(rigid_sel_string)
        f.close()
        
        with open(reqfolder+"rigid_residues_CA.txt", 'w+') as f: 
            f.write(rigid_CA_sel_string)
        f.close()
        
        return rigid_sel_string,rigid_CA_sel_string
       
    def get_ligand_bound_COM(traj_file, tpr_file, rigid_CA_sel_string, ligand_name, ref_frame,reqfolder=""):
        # Load the trajectory twice, one for ref, one for alignment
        fullmobileuniverse = mda.Universe(tpr_file,traj_file,tpr_resid_from_one=False)
        fullrefuniverse = mda.Universe(tpr_file,traj_file,tpr_resid_from_one=False)
        
        # Set the ref trajectory to ref_frame, and the mobile universe to last frame
        fullmobileuniverse.trajectory[-1]
        fullrefuniverse.trajectory[ref_frame]
        
        # Align the mobile trajectory its ref_frame
        alignment = align.AlignTraj(fullmobileuniverse,fullrefuniverse,select=rigid_CA_sel_string,in_memory=True)
        #alignment = align.AlignTraj(fullmobileuniverse,fullrefuniverse,select=rigid_CA_sel_string)
        alignment.run()
        
        # Make group for heavy STI atoms
        fullmobile_ligandgroup = fullmobileuniverse.select_atoms("resname "+ligand_name+" and not type H*")
        
        # Reset mobile trajectory to first frame, jsut to be sure
        fullmobileuniverse.trajectory[0]
        
        # Save the ligand COM positions to a list, and determine avg 
        STI_comlist = []
        for ts in fullmobileuniverse.trajectory[ref_frame:]:
            STI_comlist.append(fullmobile_ligandgroup.center_of_mass())
        bound_COM = np.average(np.array(STI_comlist),axis=0)
        
        print("Bound_COM: "+str(bound_COM))
        np.save(reqfolder+"bound_COM.npy",bound_COM)
        
        return bound_COM
        
    def get_universes(traj_file,tpr_file,rigid_CA_sel_string,ligand_name,ref_frame,reqfolder=""):
        print("init func")
        # Universe with all atoms (solvent, P, L, ions..)
        fulluniverse = mda.Universe(tpr_file,tpr_resid_from_one=False) 
        #### Now the minimalistic universes, because smaller universes live fast (??)
        print("i got full universe")
        # First load a dummy universe
        tempuniverse = mda.Universe(tpr_file,tpr_resid_from_one=False)
        print("even tempofull")
        # Create group with rigid CA and heavy ligand atoms, the 'minimal group'
        minimal_group = tempuniverse.select_atoms("("+rigid_CA_sel_string+") or (resname "+ligand_name+" and not type H*)")
        print("minimal group selected")
        # Then create your minimalistic universe, populate it with the essentials
        time.sleep(10)
        print("slept")
        minimaluniverse = mda.Merge(minimal_group)
        print("even did the merge")
        # For the reference minimalistic universe, we need positional info too
        # We start again with a dummy universe, with entire trajectory
        tempouniverse = mda.Universe(tpr_file, traj_file,tpr_resid_from_one=False)
        
        # Set the trajectory to the ref_frame
        tempouniverse.trajectory[ref_frame]
        
        # Create the same minimal group for this universe
        minimalo_group = tempouniverse.select_atoms("("+rigid_CA_sel_string+") or (resname "+ligand_name+" and not type H*)")
        
        # Now, write the the coordinates to a file. We will then load it in a new minimalistic universe
        with mda.Writer(reqfolder+'ref_frame_minimal_coords.xtc',n_atoms=minimalo_group.n_atoms) as w:
            w.write(minimalo_group.atoms)
            
        # Create the ref minimalistic universe
        minimalrefuniverse = mda.Merge(minimalo_group.atoms)
        
        # And distribute the essentials with the saved positions
        minimalrefuniverse.load_new(reqfolder+'ref_frame_minimal_coords.xtc')
        
        # Finally, we create groups for P and L in the minimalistic universes
        # We will need them during the actual orderparameter calculations
        minimalPgroup = minimaluniverse.select_atoms("protein")
        minimalLgroup = minimaluniverse.select_atoms("resname "+ligand_name)
        minimalrefPgroup = minimalrefuniverse.select_atoms("protein")
        minimalrefLgroup = minimalrefuniverse.select_atoms("resname "+ligand_name)
        
        return fulluniverse, minimaluniverse, minimalrefuniverse, minimalPgroup, minimalLgroup, minimalrefPgroup, minimalrefLgroup
        
    def load_bound_COM(bound_com_fn):
        return np.load(bound_com_fn)
    
    def load_rigid_sel(fn_rig, fn_rig_CA):
        str_rig = ""
        str_rig_CA = ""
        with open(fn_rig,'r') as f:
            str_rig = f.readline()
        f.close()
        
        with open(fn_rig_CA, 'r') as f: 
            str_rig_CA = f.readline()
        f.close()
        
        return str_rig, str_rig_CA
    
    
    # Recalculation starts here:
    for file_gro in traj_files:
        print("I'm doing another trajectory: "+str(file_gro))
        assert os.path.isfile(file_gro), 'You are trying to use a non-existing trajectory: '+traj
        #import MDAnalysis as mda

        # tpx version, default = "old"
        tpx_version = options.tpx_version

        # We will save it to a txt file
        out_fn = os.path.split(file_gro)[0]+"/../"+(os.path.split(file_gro)[1])[:-4]+"_lambdas.txt"
    
        # Required files to run this are in this folder
        reqfolder = options.reqfolder+"/"
        
        if tpx_version == "old":
            tpr_file = reqfolder+"topol_old.tpr"
        elif tpx_version == "new":
            tpr_file = reqfolder+"topol_new.tpr"
        else:
            print("Uh-oh, wrong tpx entry. Choose old or new.")
    
        # Basic parameters
        ref_frame = options.ref_frame
        ligand_name = "STI"
        
        # Initial trajectory files
        gro_file = reqfolder+"init_center.gro"
        traj_file = reqfolder+"fullsimcenter.xtc"
        #####################################################
        #####################################################
        #######                                      ########
        #######   ACTUAL RECALCULATION STARTS HERE   ########
        #######                                      ########
        #####################################################
        #####################################################
        
        # Calculating the rigid residues
        #rigid_sel_string, rigid_CA_sel_string = get_rigid_residues_id(gro_file, traj_file, 0.08, ref_frame,reqfolder)
        
        # Calculating the ligand COM position
        #ligand_bound_COM = get_ligand_bound_COM(traj_file,tpr_file,rigid_CA_sel_string,ligand_name,ref_frame,reqfolder)
        
        # Or, if available, just load them!
        rigid_sel_string, rigid_CA_sel_string = load_rigid_sel(reqfolder+"rigid_residues.txt",reqfolder+"rigid_residues_CA.txt")
        bound_COM = load_bound_COM(reqfolder+"bound_COM.npy")
        
        # Setting the universes and atom groups for orderp calculation
        fulluniverse, minimaluniverse, minimalrefuniverse, minimalPgroup, minimalLgroup, minimalrefPgroup, minimalrefLgroup = get_universes(traj_file,tpr_file,rigid_CA_sel_string,ligand_name,ref_frame,reqfolder)
        # Our orderparameter list
        bufferlist = []
        ##############################
        # Starting the recalculation #
        ##############################
        
        fulluniverse.load_new(file_gro, refresh_offsets=True)
        
        dt = fulluniverse.trajectory.dt #float, ps
        print("timestep: "+str(dt)+" ps")
        n_flushframes = fulluniverse.trajectory.n_frames
        
        p = subprocess.Popen(['gmx', 'trjconv', '-center', '-pbc', 'mol', \
                              '-f', file_gro, '-s', tpr_file, '-o', \
                              'protwhole_'+str(cid)+'.xtc', '-n', reqfolder+'analysis_index.ndx'], \
                              stdin=subprocess.PIPE)
        p.communicate(b'1\n22\n')
        p.wait()
        
        q = subprocess.Popen(['gmx', 'trjconv', '-pbc', 'nojump', \
                              '-f', "protwhole_"+str(cid)+".xtc", '-o', \
                              'minimalunwrap_'+str(cid)+'.xtc', '-n', reqfolder+'analysis_index.ndx'], \
                              stdin=subprocess.PIPE)
        q.communicate(b'24\n')
        q.wait()
        
        print("starting alignment")
        minimaluniverse.load_new("minimalunwrap_"+str(cid)+".xtc", refresh_offsets=True)
        alignment = align.AlignTraj(minimaluniverse,minimalrefuniverse,select="protein",in_memory=True)
        alignment.run()
        print("ended alignment")
        
        for ts in minimaluniverse.trajectory:
            mdalambda = distances.distance_array(bound_COM,minimalLgroup.center_of_mass(),box=fulluniverse.trajectory.ts.dimensions)[0][0]
            bufferlist.append(mdalambda)
        os.remove("minimalunwrap_"+str(cid)+".xtc")
        os.remove("protwhole_"+str(cid)+".xtc") 
        write_order(bufferlist,out_fn,dt=dt)
        with open(outf+"/donetrajs_chunk_"+str(cid)+".txt", 'a+') as tempf:
            tempf.write("I did yet another trajectory: "+str(file_gro)+"\n")
